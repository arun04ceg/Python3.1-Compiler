;
;This project is done by Arun Baskar(u0811338) along with Arvind Haran(u0809850). 
;
;
; <program> ::= (program <stmt>*)
(file_input      ($-->(seq* 
                 (rep 
                 (or 
                 NEWLINE
                 stmt
                 )) ENDMARKER
                 ) `(program ,@ ($ 0))))

; <funcdef> ::= (def (<NAME> <NAME>*) <suite>)
(funcdef         ($-->(seq* "def" NAME parameters ":" suite)
                 `(def ,(list* ($ 1) ($ 2)) ,($ 4))
                 ))


(parameters      ($-->(seq* "(" (opt paramlist #f) ")")
                 (if ($ 1)
                 ($ 1)
                 '()
                 )))


(paramlist       ($-->(seq* (seq NAME (rep (car (seq! "," `NAME)))) (opt "," `()))
                 ($ 0)
                 ))

; <stmt> ::= <simple_stmt> | <compound_stmt>
(stmt            (or simple_stmt compound_stmt))

; <simple_stmt> ::= <small_stmt> | (begin <small_stmt>+)
(simple_stmt     ($-->(seq* (seq small_stmt (rep (car (seq! ";" `small_stmt)))) (opt ";" #f) NEWLINE)
                 (if (not (null? (cdr ($ 0))))
                 `(begin ,(car ($ 0)),@ (cdr ($ 0)))
                 (car ($ 0))
                 )))

; <small_stmt> ::= <expr_stmt>
;               |  <del_stmt>
;               |  <pass_stmt>
;               |  <flow_stmt> 
;               |  <global_stmt>
;               |  <nonlocal_stmt>
;               |  <assert_stmt>
(small_stmt      (or expr_stmt del_stmt pass_stmt flow_stmt global_stmt nonlocal_stmt assert_stmt))

; <expr_stmt> ::= (<augassign> (<test>+) <tuple_or_test>)
;              |  (=           (<test>+) <tuple_or_test>)
;              |  (expr <tuple_or_test>)
(expr_stmt       (or 
                 ($-->(seq* testlist augassign tuple_or_test) `(,($ 1) ,($ 0) ,($ 2)))
                 ($-->(seq* testlist "=" tuple_or_test) `(,(string->symbol ($ 1)) ,($ 0), ($ 2)))
                 ($-->(seq* tuple_or_test) `(expr ,($ 0)))
                 ))

; <augassign> ::= "+=" | "-=" | "*=" | "/="  | "%="
;              |  "&=" | "|=" | "^=" | "<<=" | ">>=" | "**=" | "//="
(augassign       (or "+=" "-=" "*=" "/=" "%=" "&=" "|=" "^=" "<<=" ">>=" "**=" "//="))

; <del_stmt> ::= (del <star_expr>)
(del_stmt        (seq* "del" star_expr))

; <pass_stmt> ::= (pass)
(pass_stmt       ($-->(seq* "pass") '(pass)))

; <flow_stmt> ::= <break_stmt> | <continue_stmt> | <return_stmt> | <raise_stmt>
(flow_stmt       (or break_stmt continue_stmt return_stmt raise_stmt))

; <break_stmt> ::= (break)
(break_stmt      ($-->(seq* "break") '(break)))

; <continue_stmt> ::= (continue)
(continue_stmt   ($-->(seq* "continue") '(continue)))

; <return_stmt> ::= (return <test>*)
(return_stmt     ($-->(seq* "return" (opt testlist #f))
                 (if ($ 1)
                 `(return ,@($ 1))
                 '(return)
                 )))

; <raise_stmt> ::= (raise [ <test> [ <test> ] ])
(raise_stmt      ($-->(seq* "raise" (opt (seq* test (opt (car (seq! "from" `test)) #f)) #f))
                 (if ($ 1)
                 (if (cadr ($ 1))
                 `(raise ,(car ($ 1)) ,(cadr ($ 1)))
                 `(raise ,(car ($ 1)))
                 )
                 `(raise)
                 )))

; <global_stmt> ::= (global <NAME>+) 
(global_stmt     ($-->(seq* "global" NAME (rep (car (seq! "," `NAME))))
                 (if ($ 2)
                 `(global ,($ 1),@ ($ 2))
                 `(global ,($ 1))
                 )))

; <nonlocal_stmt> ::= (nonlocal <NAME>+)
(nonlocal_stmt   ($-->(seq* "nonlocal" NAME (rep (car (seq! "," `NAME))))
                 (if ($ 2)
                 `(nonlocal ,($ 1),@ ($ 2))
                 `(nonlocal ,($ 1))
                 )))

; <assert_stmt> ::= (assert <test> [ <test> ])
(assert_stmt     ($-->(seq* "assert" test (opt (seq! "," `test) #f))
                 (if ($ 2)
                 `(assert ,($ 1) ,(car ($ 2)))
                 `(assert ,($ 1))
                 )))

; <compound_stmt> ::= <if_stmt> | <while_stmt> | <for_stmt> | <try_stmt> | <funcdef>
(compound_stmt   (or if_stmt while_stmt for_stmt try_stmt funcdef))

; <if_stmt> ::= (cond (<test> <suite>)+ [ (else <suite>) ])
(if_stmt         ($-->(seq* "if" test ":" suite (rep (seq! "elif" `test ":" `suite)) (opt (seq* "else" ":" suite) #f))
                 (if ($ 5)
                 `(cond ,(list ($ 1) ($ 3)) ,@($ 4) ,(list 'else (caddr ($ 5))))
                 `(cond ,(list ($ 1) ($ 3)) ,@($ 4))
                 )))

; <while_stmt> ::= (while <test> <suite> [ <suite> ])
(while_stmt      ($-->(seq* "while" test ":" suite (opt (seq* "else" ":" suite) #f))
                 (if ($ 4)
                 `(while ,($ 1) ,($ 3) ,(caddr ($ 4)))
                 `(while ,($ 1) ,($ 3))
                 )))

; <for_stmt> ::= (for <NAME> <test> <suite> [ <suite> ])        
(for_stmt        ($-->(seq* "for" NAME "in" test ":" suite (opt (seq* "else" ":" suite) #f))
                 (if ($ 6)
                 `(for ,($ 1) ,($ 3) ,($ 5) ,(caddr ($ 6)))
                 `(for ,($ 1) ,($ 3) ,($ 5))
                 )))

; <try_stmt>      ::= (try <suite> ((<catch> <suite>)*) <maybe-else> <maybe-finally>)
(try_stmt        ($-->(seq* "try" ":" suite try_rest)
                 `(try ,($ 2) ,@($ 3))
                 ))
                 
(try_rest        (or 
                 ($-->(seq* (rep+ (seq! `except_clause ":" `suite)) (opt (car (seq! "else" ":" `suite)) #f) (opt (car (seq! "finally" ":" `suite)) #f)) `(,($ 0) ,($ 1) ,($ 2))) 
                 ($-->(seq! "finally" ":" `suite) `(,'() ,#f ,($ 0)))
                 ))
;(try_stmt        (seq "try" ":" suite (or (seq (rep+ (seq except_clause ":" suite)) (opt (seq "else" ":" suite)) (opt (seq "finally" ":" suite))) (seq "finally" ":" suite))))

;<catch> ::= (except [ <test> [ <NAME> ] ])
(except_clause   ($-->(seq* "except" (opt (seq* test (opt (car (seq! "as" `NAME)) #f)) #f))
                 (if ($ 1)
                 (if (cadr ($ 1))
                 `(except ,(car ($ 1)) ,(cadr ($ 1)))
                 `(except ,(car ($ 1)))
                 )
                 `(except)
                 )))

; <suite> ::= <simple_stmt> | (suite <stmt>+)
(suite           (or 
                 simple_stmt 
                 ($-->(seq* NEWLINE INDENT (rep+ stmt) DEDENT) `(suite ,@ ($ 2)))
                 ))

; <test> ::= (if <or_test> <or_test> <test>)
;         |  <or_test>
;         |  <lambdef>
(test            (or 
                 ($-->(seq* or_test "if" or_test "else" test) `(if ,($ 2) ,($ 0) ,($ 4)))
                 or_test 
                 lambdef))

; <lambdef> ::= (lambda (<NAME>*) <test>)
(lambdef         ($-->(seq* "lambda" (opt paramlist '()) ":" test)
                 `(lambda ,($ 1), ($ 3))
                 ))

; <or_test> ::= <and_test> | (or <and_test>+)
(or_test         ($-->(seq* and_test (rep (car (seq! "or" `and_test))))
                 (if (null? ($ 1))
                 ($ 0)
                 `(or ,($ 0),@ ($ 1))
                 )))

; <and_test> ::= <not_test> | (and <not_test>+)
(and_test        ($-->(seq* not_test (rep (car (seq! "and" `not_test))))
                 (if (null? ($ 1))
                 ($ 0)
                 `(and ,($ 0),@ ($ 1))
                 )))

; <not_test> ::= <comparison> | (not <not_test>)
(not_test        (or (seq* "not" not_test) comparison))

; <comparison> ::= <star_expr> | (comparison <star_expr> (<comp_op> <star_expr>)+)
(comparison      ($-->(seq* star_expr (rep (seq* comp_op star_expr)))
                 (if (null? ($ 1))
                 ($ 0)
                 `(comparison ,($ 0) ,@ ($ 1))
                 )))

; <comp_op> ::= "<" | ">" | "==" | ">=" | "<=" | "<>" | "!= " | "in"
;            |  "not-in" | "is" | "is-not"
(comp_op         (>-->(or "<" ">" "==" ">=" "<=" "<>" "!=" "in" (seq* "not" "in") "is" (seq* "is" "not"))
                 [(list a b) (string-append (symbol->string a) "-" (symbol->string b))]
                 [a (if (symbol? a) (symbol->string a) a)]
                 ))

; <star_expr> ::= <expr> | (star <expr>)
(star_expr       ($-->(seq* (opt "*" #f) expr)
                 (if ($ 0)
                 `(star ,($ 1))
                 ($ 1)
                 )))

; <expr> ::= <xor_expr> | (bitwise-or <xor_expr>+)
(expr            ($-->(seq* xor_expr (rep (car (seq! "|" `xor_expr))))
                 (if (null? ($ 1))
                 ($ 0)
                 `(bitwise-or ,($ 0),@ ($ 1))
                 )))

; <xor_expr> ::= <and_expr> | (bitwise-xor <and_expr>+)
(xor_expr        ($-->(seq* and_expr (rep (car (seq! "^" `and_expr))))
                 (if (null? ($ 1))
                 ($ 0)
                 `(bitwise-xor ,($ 0),@ ($ 1))
                 )))

; <and_test> ::= <not_test> | (and <not_test>+)
(and_expr        ($-->(seq* shift_expr (rep (car (seq! "&" `shift_expr))))
                 (if (null? ($ 1))
                 ($ 0)
                 `(bitwise-and ,($ 0),@ ($ 1))
                 )))

; <shift_expr> ::= <arith_expr> | (shift <arith_expr> (<shift_op> <arith_expr>)+)
(shift_expr      ($-->(seq* arith_expr (rep (seq* (or "<<" ">>") arith_expr)))
                 (if (null? ($ 1))
                 ($ 0)
                 `(shift ,($ 0),@ ($ 1))
                 )))

; <arith_expr> ::= <term> | (arith <term> (<arith_op> <term>)+)
(arith_expr      ($-->(seq* term (rep (seq* (or "+" "-") term)))
                 (if (null? ($ 1))
                 ($ 0)
                 `(arith ,($ 0),@ ($ 1))
                 )))

; <term> ::= <factor> | (term <factor> (<factor_op> <factor>)+)
(term            ($-->(seq* factor (rep (seq* (or "*" "/" "%" "//") factor)))
                 (if (null? ($ 1))
                 ($ 0)
                 `(term ,($ 0),@ ($ 1))
                 )))

; <factor> ::= <power> | (<unary_op> <factor>)
(factor          (or (seq* (or "+" "-" "~") factor) power))

; <indexed> ::= <atom> | (indexed <atom> <trailer>+)
(indexed         ($-->(seq* atom (rep trailer))
                 (if (null? ($ 1))
                 ($ 0)
                 `(indexed ,($ 0) ,@($ 1))
                 )))

; <power> ::= <indexed> | (power <indexed> <factor>)
(power           ($-->(seq* indexed (opt (seq! "**" `factor) #f))
                 (if ($ 1)
                 `(power ,($ 0) ,@($ 1))
                 ($ 0)
                 )))

; <atom> ::= <tuple_or_test> | (tuple)
;         |  (list [ <testlist> ])
;         |  <dict>
;         |  <set>
;         |  <NAME>
;         |  <NUMBER>
;         |  <STRING>
;         |  Ellipsis
;         |  None
;         |  True
;         |  False
(atom            (or 
                 ($-->(seq* "(" (opt tuple_or_test #f) ")")  (if ($ 1) ($ 1) '(tuple)))
                 ($-->(seq* "[" (opt testlist #f) "]")  (if ($ 1) `(list ,@ ($ 1)) '(list)))
                 ($-->(seq* "{" (opt dictorsetmaker #f) "}") (if ($ 1) ($ 1) '(dict))) 
                 NAME 
                 NUMBER 
                 (@-->(rep+ STRING) string-append)
                 ($--> "..." 'Ellipsis)
                 "None" 
                 "True" 
                 "False"
                 ))

; <trailer> ::= (called [ <arglist> ])
;            |  (subscript <tuple_or_test>)
;            |  (dot <NAME>)
(trailer        (or 
                ($-->(seq* "(" (opt arglist #f) ")") (if ($ 1) 
                                                    `(called ,@($ 1))
                                                    '(called)))
                ($-->(seq* "[" tuple_or_test "]") `(subscript ,($ 1)))
                ($-->(seq* "." NAME) `(dot ,($ 1)))
                ))

; <testlist> ::= <test>+ 
(testlist       ($-->(seq* (seq test (rep (car (seq! "," `test)))) (opt "," '()))
                ($ 0)
                ))

; <tuple_or_test> ::= <test> | (tuple <test>+)
(tuple_or_test  ($-->(seq* test (rep (car (seq! "," `test))) (opt "," '()))
                (if (null? ($ 1))
                (if (null? ($ 2))
                ($ 0)
                `(tuple ,($ 0)))
                `(tuple ,($ 0) ,@($ 1))
                )
                ))


; <dict> ::= (dict (<test> <test>)*) 
; <set> ::= (set <test>*)
(dictorsetmaker (or 
                ($--> (seq* (seq (seq! `test ":" `test) (rep (seq! "," `test ":" `test))) (opt "," #f)) `(dict ,@($ 0)))
                ($--> (seq* (seq test (rep (car (seq! "," `test)))) (opt "," #f)) `(set ,@($ 0)))
                ))

; <arglist> ::= <test>+
(arglist        ($-->(seq* (seq test (rep (car (seq! "," `test)))) (opt "," '()))
                ($ 0)
                ))

;
;This project is done by Arun Baskar(u0811338) along with Arvind Haran(u0809850).                      
;
;
